
local Fluent = loadstring(game:HttpGet("https://github.com/dawid-scripts/Fluent/releases/latest/download/main.lua"))()
local SaveManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/SaveManager.lua"))()
local InterfaceManager = loadstring(game:HttpGet("https://raw.githubusercontent.com/dawid-scripts/Fluent/master/Addons/InterfaceManager.lua"))()
local espLib = loadstring(game:HttpGet(('https://raw.githubusercontent.com/idontknowwhattonamemyself/modified/Lua/new'),true))()
espLib.chams = false
espLib.boxesColor = Color3.new(255,255,255)

local anims = {
    ["Pumped Up"] = "rbxassetid://14733282425",
    ["Brutal Beatdown"] = "rbxassetid://14701242661", 
    ["Maximum Energy Output"] = "rbxassetid://14701242661",
    ["Incinerate"] = "rbxassetid://13146710762",
    ["Flamewave Cannon"] = "rbxassetid://13083332742",
}
local stunnames = {
"NoBlock",
"NoJump",
"StopRunning",
"Freeze",
"Slowed",
"ComboStun",
}
local Window = Fluent:CreateWindow({
    Title = "Sillyware",
    SubTitle = "UI Version: "..Fluent.Version,
    TabWidth = 160,
    Size = UDim2.fromOffset(580, 460),
    Acrylic = false, -- The blur may be detectable, setting this to false disables blur entirely
    Theme = "Dark",
    MinimizeKey = Enum.KeyCode.LeftControl -- Used when theres no MinimizeKeybind
})
function getchar(plr)
    local char
    if plr.Character ~= nil and plr:FindFirstChild("HumanoidRootPart") and plr:FindFirstChild("Humanoid") then
        char = plr.Character
    end
    return char
end
function moveoncd(number)
    if game:GetService("Players").LocalPlayer.PlayerGui.Hotbar.Backpack.Hotbar:FindFirstChild(number).Base:FindFirstChild("Cooldown") then 
    return true
    end
    return false
    end
function getlchar()
local char
if game:GetService("Players").LocalPlayer.Character ~= nil and game:GetService("Players").LocalPlayer:FindFirstChild("HumanoidRootPart") and game:GetService("Players").LocalPlayer:FindFirstChild("Humanoid") then
char = game:GetService("Players").LocalPlayer.Character
end
return char
end
function gethumanoid(player)
    local a = character(player)
    if a == nil then return end
    return a.Humanoid
end
function getlhumanoid()
local a = getlchar()
if a == nil then return end
return a.Humanoid
end
function playanim(id)
    local anim = Instance.new("Animation")
    anim.AnimationId = id
    loaded = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
    loaded.Priority = Enum.AnimationPriority.Action
    loaded:Play()
end
function getclosest(range)
    local closest
    local closestmag = range
    if not game:GetService("Players").LocalPlayer.Character or not game:GetService("Players").LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then return nil end
    local plrhrp = game:GetService("Players").LocalPlayer.Character.HumanoidRootPart
    for i, v in pairs(game:GetService("Players"):GetPlayers()) do 
        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") and v ~= game:GetService("Players").LocalPlayer  then
        local hrp = v.Character:FindFirstChild("HumanoidRootPart")
        local mag = (hrp.Position - plrhrp.Position).Magnitude
        if mag < closestmag then closest = v; closestmag = mag end
        end
    end
    return closest
end
--Fluent provides Lucide Icons https://lucide.dev/icons/ for the tabs, icons are optional
local Tabs = {
    Main = Window:AddTab({ Title = "Main", Icon = "skull" }),
    ExploitsTab = Window:AddTab({ Title = "Exploits", Icon = "skull" }),
    Misc = Window:AddTab({ Title = "Misc", Icon = "ban" }),
    PlayEmotes = Window:AddTab({ Title = "Emotes", Icon = "laugh" }),
    Settings = Window:AddTab({ Title = "Settings", Icon = "settings" })
}

local Options = Fluent.Options
workspace.FallenPartsDestroyHeight = -50000
function notify(text, length)
    Fluent:Notify({
        Title = "Sillyware.meow",
        Content = text,
        Duration = length -- Set to nil to make the notification not disappear
    })

end
    Fluent:Notify({
        Title = "Sillyware.meow",
        Content = "If you dont see a fully loaded notification, please type /console and screenshit the bottom pls",
        Duration = 5 -- Set to nil to make the notification not disappear
    })



    -- Tabs.Main:AddParagraph({
    --     Title = "Paragraph",
    --     Content = "This is a paragraph.\nSecond line!"
    -- })

    -- Tabs.Main:AddButton({
    --     Title = "Button",
    --     Description = "Very important button",
    --     Callback = function()
    --         Window:Dialog({
    --             Title = "Title",
    --             Content = "This is a dialog",
    --             Buttons = {
    --                 {
    --                     Title = "Confirm",
    --                     Callback = function()
    --                         print("Confirmed the dialog.")
    --                     end
    --                 },
    --                 {
    --                     Title = "Cancel",
    --                     Callback = function()
    --                         print("Cancelled the dialog.")
    --                     end
    --                 }
    --             }
    --         })
    --     end
    -- })


    Tabs.Misc:AddButton({
            Title = "Force Reset",
            Description = "Resets Character (no need to wait for no combat)",
            Callback = function()
                pcall(function()
                    game.Players.LocalPlayer.Character.Humanoid.Health = 0
                end)
            end
    })
    local safeplace
    Tabs.Misc:AddButton({
        Title = "Set Safe Place",
        Description = "Sets your safe place so u can tp to it later!",
        Callback = function()
            pcall(function()
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                safeplace = game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").Position
                end
            end)
        end
    })
    local Ctoggle = Tabs.Misc:AddToggle("AutoTptosafeplace", {Title = "Tp to safe place when low", Default = false })
    local autosp = false
    local hpamt = 30
    Ctoggle:OnChanged(function(Value)
        autosp = Value
    end)
    spawn(function()
        while wait() do
        pcall(function()
            if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character.HumanoidRootPart and game.Players.LocalPlayer.Character.Humanoid and safeplace ~= nil and game.Players.LocalPlayer.Character.Humanoid.Health <= hpamt then
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = safeplace
            end
        end)
        end
    end)
    local Slider = Tabs.Misc:AddSlider("SPHEALTH", {
        Title = "Auto Safe Place Health",
        Description = "HP",
        Default = 30,
        Min = 5,
        Max = 75,
        Rounding = 1,
        Callback = function(Value)
            hpamt = Value
        end
    })

    Tabs.Misc:AddButton({
        Title = "Goto Safe Place",
        Description = "Teleports To Your Saved Safe Place",
        Callback = function()
            pcall(function()
                if game.Players.LocalPlayer.Character and game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    game.Players.LocalPlayer.Character:FindFirstChild("HumanoidRootPart").CFrame = CFrame.new(safeplace)
                end
            end)
        end
    })
    local Ctoggle = Tabs.ExploitsTab:AddToggle("CharOffset", {Title = "Character Offset", Default = false })
    local co = false
    local hlight
    local loaded
    Ctoggle:OnChanged(function(Value)
        co = Value
        pcall(function()
        if Value == true then 
            hlight = Instance.new("Highlight")
            hlight.Parent = game.Players.LocalPlayer.Character.HumanoidRootPart
            game.Players.LocalPlayer.Character.HumanoidRootPart.Transparency = 0
        else
            if hlight ~= nil then 
            hlight:Destroy()
            end
            game.Players.LocalPlayer.Character.HumanoidRootPart.Transparency = 1
            for i, v in pairs(game.Players.LocalPlayer.Character.Humanoid.Animator:GetPlayingAnimationTracks()) do
            v:Stop()
            v:Destroy()
            end
        end
        end)
    end)
    local Keybind = Tabs.ExploitsTab:AddKeybind("CHAROFFSETKB", {
        Title = "KeyBind",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "G", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
            Options.CharOffset:SetValue(not co)
        end,

        -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
        ChangedCallback = function(New)
        end
    })
    Tabs.ExploitsTab:AddParagraph({
        Title = "Deadly Ninja Exploits",
        Content = "ALL BELOW EXPLOITS REQUIRE DEADLY NINJA TO BE EQUIPPED!"
    })
    local Ctoggle = Tabs.ExploitsTab:AddToggle("KILLALL", {Title = "Kill All", Default = false})
    local tpall = false
    local killall = false
    Ctoggle:OnChanged(function(Value)
        if game.Players.LocalPlayer.Backpack:FindFirstChild("Scatter") then
            killall = Value
        elseif Value == true then
            Options.KILLALL:SetValue(false)
            notify("Please Equip Sonic Base Form (Deadly Ninja)", 1)
        end
    end)
    Tabs.ExploitsTab:AddButton({
        Title = "Manual Void Player",
        Description = "Grab Player with scatter or any other move that grabs and press this to use manual version",
        Callback = function()
            if tpvoid == true then notify("Already Teleporting To Void...") return end
            pcall(function()
                local savedpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                tpvoid = true
                wait(3)
                tpvoid = false
                wait(.1)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedpos
            end)
        end
    })
    local Keybind = Tabs.ExploitsTab:AddKeybind("NOCLIPKB", {
        Title = "KeyBind",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "J", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
            if tpvoid == true then notify("Already Teleporting To Void...") return end
            pcall(function()
                local savedpos = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                tpvoid = true
                wait(3)
                tpvoid = false
                wait(.1)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedpos
            end)
        end,

        -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
        ChangedCallback = function(New)
        end
    })
    local player = ""
    local Input = Tabs.ExploitsTab:AddInput("Input", {
        Title = "Player Username",
        Default = "Type Random Here For a Random Player",
        Placeholder = "Type Random Here For a Random Player",
        Numeric = false, -- Only allows numbers
        Finished = false, -- Only calls callback when you press enter
        Callback = function(Value)
            player = Value
        end
    })
    Tabs.ExploitsTab:AddButton({
        Title = "Bring Player",
        Description = "Brings The Player",
        Callback = function()
            pcall(function()
                local playerinst
                if string.lower(player) ~= "Random" then
                    playerinst = game.Players:FindFirstChild(player)
                else
                    playerinst = game.Players:GetPlayers()[math.random(2, #game.Players:GetPlayers())]
                end
                if not playerinst then notify("Cant Find Player: ".. player) return end
                if not moveoncd("3") then
                    local savedposition = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                    local args = {
                        [1] = {
                            ["Goal"] = "Console Move",
                            ["Tool"] = game:GetService("Players").LocalPlayer.Backpack:WaitForChild("Scatter")
                        }
                    }
                    
                    game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                    
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    wait(.25)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    wait(.25)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    wait(.25)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    wait(.25)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    wait(.25)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                    game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
                    game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                    wait(.1)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
                    wait(.1)
                    game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
                else 
                    notify("Error: Scatter On Cooldown", 1)
                end
            end)
        end
    })
    spawn(function()
    while wait() do
    pcall(function()
        if tpall == true then
        for i, v in pairs(game.Players:GetPlayers()) do
        if v.Character and v.Character:FindFirstChild("HumanoidRootPart") then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = v.Character.HumanoidRootPart.CFrame
            wait(.1)
        end
        end
    end
        if tpvoid == true then
            game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-49000, 0)
        end
    end)
    end
    end)
    Tabs.ExploitsTab:AddButton({
        Title = "Kill Player",
        Description = "Brings The Player",
        Callback = function()
            pcall(function()
                local player
                local playerinst
                if string.lower(player) ~= "Random" then
                    playerinst = game.Players:FindFirstChild(player)
                else
                    playerinst = game.Players:GetPlayers()[math.random(2, #game.Players:GetPlayers())]
                end
                if not playerinst then notify("Cant Find Player: ".. player) return end

                local savedposition = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
                local args = {
                    [1] = {
                        ["Goal"] = "Console Move",
                        ["Tool"] = game:GetService("Players").LocalPlayer.Backpack:WaitForChild("Scatter")
                    }
                }
                game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
                wait(.25)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                wait(.25)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                wait(.25)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                wait(.25)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = playerinst.Character.HumanoidRootPart.CFrame
                tpvoid = true
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-40000,0)
                wait(.25)
                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-40000,0)
                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                wait(.1)
                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
                wait(.5)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
                wait(.1)
                game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
                wait(1)
                tpvoid = false
            end)
        end
    })
    spawn(function()
    while wait() do
    if killall == true then
        pcall(function()
        if not moveoncd("3") then
        local savedposition = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame
        workspace.FallenPartsDestroyHeight = -50000
        local args = {
            [1] = {
                ["Goal"] = "Console Move",
                ["Tool"] = game:GetService("Players").LocalPlayer.Backpack:WaitForChild("Scatter")
            }
        }
        
        game:GetService("Players").LocalPlayer.Character.Communicate:FireServer(unpack(args))
        wait(.25)
        tpall = true
        wait(1.25)
        tpall = false
        tpvoid = true
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.new(0,-1000,0)
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
        wait(.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = Vector3.new()
        wait(1.5)
        tpvoid = false
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
        wait(.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition
        wait(.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = savedposition

    end
    end)
    else
        workspace.FallenPartsDestroyHeight = defaultdestroyheight
    end
    end
    end)
    local id = "rbxassetid://13633468484"
    local anim = Instance.new("Animation")
    anim.AnimationId = id
    spawn(function()
    while wait() do
        pcall(function()
        if co == true then
        loaded = game.Players.LocalPlayer.Character.Humanoid.Animator:LoadAnimation(anim)
        loaded.Priority = Enum.AnimationPriority.Action4
        loaded:Play()
        loaded.TimePosition = 4
        loaded:AdjustSpeed(0)
        end
        end)
    end
    end)
    local esp = false
    local Toggle = Tabs.Main:AddToggle("ESPTOG", {Title = "ESP", Default = false })
    Toggle:OnChanged(function(Value)
        if Value == true then
            espLib:Load()
        elseif esp == true then
            espLib:Unload()
        end
        esp = Value
    end)
    local Toggle = Tabs.Main:AddToggle("NCLIP", {Title = "Noclip", Default = false })
    local noclip = false
    Toggle:OnChanged(function(Value)
        noclip = Value
    end)
    
    local Keybind = Tabs.Main:AddKeybind("NOCLIPKB", {
        Title = "KeyBind",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "N", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
            Options.NCLIP:SetValue(not noclip)
        end,

        -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
        ChangedCallback = function(New)
        end
    })
    local Toggle = Tabs.Main:AddToggle("FLYTOG", {Title = "Fly", Default = false })
    local fly = false
    local speed = 150
    Toggle:OnChanged(function(Value)
        fly = Value
    end)
    game:GetService("RunService").RenderStepped:Connect(function()
        if fly == true then 
            if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Space) or game.Players.LocalPlayer.Character.Humanoid.Jump == true then
                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = (game.Players.LocalPlayer.Character.Humanoid.MoveDirection * speed) + Vector3.new(0,speed,0)    
            else 
                game.Players.LocalPlayer.Character.HumanoidRootPart.Velocity = (game.Players.LocalPlayer.Character.Humanoid.MoveDirection * speed)   
            end
        end
    end)
    game:GetService("RunService").RenderStepped:Connect(function()
        if noclip == true then 
            for i, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do
                if v:IsA("BasePart") then
                v.CanCollide = false
                end
            end
        end
    end)
    local Slider = Tabs.Main:AddSlider("FSPEED", {
        Title = "Fly Speed",
        Description = "",
        Default = 150,
        Min = 1,
        Max = 999,
        Rounding = 1,
        Callback = function(Value)
            speed = Value
        end
    })
    -- Options.MyToggle:SetValue(false)

    local Keybind = Tabs.Main:AddKeybind("FLYKB", {
        Title = "KeyBind",
        Mode = "Toggle", -- Always, Toggle, Hold
        Default = "Z", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

        -- Occurs when the keybind is clicked, Value is `true`/`false`
        Callback = function(Value)
            Options.FLYTOG:SetValue(not fly)
        end,

        -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
        ChangedCallback = function(New)
        end
    })
    local Toggle = Tabs.Main:AddToggle("NOSTUN", {Title = "No Stun", Default = false })
    local nostun = false
    local Cutscenes = {

    }
    for i, v in pairs(game:GetService("ReplicatedStorage").Cutscenes:GetChildren()) do 
        table.insert(Cutscenes, {["Name"] = v.Name, ["Script"] = v})
    end
    Toggle:OnChanged(function(Value)
        nostun = Value
        if Value == false then 
            for i, v in pairs(Cutscenes) do
                v.Script.Name = v.Name
            end
        else
            for i, v in pairs(Cutscenes) do
            v.Script.Name = "a"
            end
        end
    end)
    local Toggle = Tabs.Main:AddToggle("SHOWDC", {Title = "Show Death Counter", Default = true })
    local showdc = true
    Toggle:OnChanged(function(Value)
        showdc = Value
    end)
    local Toggle = Tabs.Main:AddToggle("SHOWSU", {Title = "Show Saitama Ult", Default = true })
    local saitamault = true
    Toggle:OnChanged(function(Value)
        saitamault = Value
    end)
    local Toggle = Tabs.Main:AddToggle("NotifyDC", {Title = "Notify", Default = true })
    local notifydc = true
    Toggle:OnChanged(function(Value)
        notifydc = Value
    end)
    local foundcounters = {}
    spawn(function()
    while wait() do
        for i, v in pairs(game.Players:GetPlayers()) do 
        pcall(function()
        local char = v.Character
        if char and char:FindFirstChild("Counter") and not table.find(foundcounters, char.Counter) and showdc == true then
            table.insert(foundcounters, char.Counter)
            if showdc then
                local highlight = Instance.new("Highlight")
                highlight.Parent = char
                highlight.OutlineColor = Color3.fromRGB(255,0,0)
                spawn(function()
                char.Counter:GetPropertyChangedSignal("Parent"):Wait()
                highlight:Destroy()
                end)
            end
            if notifydc then
            notify("Player: "..v.Name.." ("..v.UserId..") \nHas Activated Death Counter")
            end 
        end
        end)
        end
    end
    end)
    spawn(function()
        pcall(function()
        while wait() do
            for i, v in pairs(game.Players:GetPlayers()) do 
            pcall(function()
            if plr.Backpack and plr.Backpack:FindFirstChild("Death Counter") and not table.find(foundcounters, plr.Backpack["Death Counter"]) and saitamault == true then
                table.insert(foundcounters, plr.Backpack["Death Counter"])
                if saitamault then
                    local highlight = Instance.new("Highlight")
                    highlight.Parent = plr.Character
                    highlight.OutlineColor = Color3.fromRGB(0,0,255)
                    spawn(function()
                    plr.Backpack["Death Counter"]:GetPropertyChangedSignal("Parent"):Wait()
                    highlight:Destroy()
                    end)
                end
                if notifydc then
                notify("Player: "..v.Name.." ("..v.UserId..") \nHas Activated Saitama Ultimate")
                end 
            end
            end)
            end
        end
    end)
        end)
    spawn(function()
        while wait() do
            if game.Players.LocalPlayer.Character then 
                for i, v in pairs(game.Players.LocalPlayer.Character:GetChildren()) do 
                    if table.find(stunnames, v.Name) then 
                        v:Destroy()
                    end
                end
            end
        end
        end)
    local Toggle = Tabs.Main:AddToggle("AB", {Title = "Attach To Back (nearest)", Default = false })
    local AB = false
    local ABrange = 30
    Toggle:OnChanged(function(Value)
        AB = Value
        wait(.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0,10,0)
    end)

    local Slider = Tabs.Main:AddSlider("ABRANGE", {
        Title = "Attach To Back Range",
        Description = "(Studs)",
        Default = 30,
        Min = 1,
        Max = 999,
        Rounding = 1,
        Callback = function(Value)
            ABrange = Value
        end
    })

    Slider:OnChanged(function(Value)
        ABrange = Value
    end)
    ABrange = 30
    local connection = game:GetService("RunService").RenderStepped:Connect(function()
        if AB == true then
        local closest = getclosest(ABrange)
        if not closest then return end
        local closestchar = closest.Character
        local closestHRP = closestchar.HumanoidRootPart
        for i, v in pairs(game.Players.LocalPlayer.Character:GetDescendants()) do if v:IsA("BasePart") then v.CanCollide = false end end
        local myHRP = game.Players.LocalPlayer.Character.HumanoidRootPart -- you mean OUR hrp!?!?!?!? haha funny communism
        local movedir = closestchar.Humanoid.MoveDirection
        myHRP.CFrame = ((closestHRP.CFrame - Vector3.new(0,5,0)) - closestHRP.CFrame.LookVector * 3) + movedir * 3
        myHRP.Velocity = Vector3.new()
        end
    end)
    local Toggle = Tabs.Main:AddToggle("AF", {Title = "Auto Face Player (nearest)", Default = false })
    local AF = false
    local AFrange = 30
    Toggle:OnChanged(function(Value)
        AB = Value
        wait(.1)
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0,10,0)
    end)

    local Slider = Tabs.Main:AddSlider("AFRANGE", {
        Title = "Range",
        Description = "(Studs)",
        Default = 30,
        Min = 1,
        Max = 999,
        Rounding = 1,
        Callback = function(Value)
            AFrange = Value
        end
    })

    Slider:OnChanged(function(Value)
        AFrange = Value
    end)
    AFrange = 30
    local connection = game:GetService("RunService").RenderStepped:Connect(function()
        if AF == true then
        local closest = getclosest(AFrange)
        if not closest then return end
        local closestchar = closest.Character
        local closestHRP = closestchar.HumanoidRootPart
        game.Players.LocalPlayer.Character.HumanoidRootPart.CFrame = CFrame.lookAt(game.Players.LocalPlayer.Character.HumanoidRootPart.Position, closestHRP.CFrame)
        workspace.CurrentCamera.CFrame = CFrame.new(workspace.CurrentCamera.Position, closestHRP.Position)
        end
    end)
    -- Options.MyToggle:SetValue(true)


    
    -- local Slider = Tabs.Main:AddSlider("Slider", {
    --     Title = "Slider",
    --     Description = "This is a slider",
    --     Default = 2,
    --     Min = 0,
    --     Max = 5,
    --     Rounding = 1,
    --     Callback = function(Value)
    --         print("Slider was changed:", Value)
    --     end
    -- })

    -- Slider:OnChanged(function(Value)
    --     print("Slider changed:", Value)
    -- end)

    -- Slider:SetValue(3)



    -- local Dropdown = Tabs.Main:AddDropdown("Dropdown", {
    --     Title = "Dropdown",
    --     Values = {"one", "two", "three", "four", "five", "six", "seven", "eight", "nine", "ten", "eleven", "twelve", "thirteen", "fourteen"},
    --     Multi = false,
    --     Default = 1,
    -- })

    -- Dropdown:SetValue("four")

    -- Dropdown:OnChanged(function(Value)
    --     print("Dropdown changed:", Value)
    -- end)
    -- MultiDropdown:OnChanged(function(Value)
    --     local Values = {}
    --     for Value, State in next, Value do
    --         table.insert(Values, Value)
    --     end
    --     print("Mutlidropdown changed:", table.concat(Values, ", "))
    -- end)



    -- local Colorpicker = Tabs.Main:AddColorpicker("Colorpicker", {
    --     Title = "Colorpicker",
    --     Default = Color3.fromRGB(96, 205, 255)
    -- })

    -- Colorpicker:OnChanged(function()
    --     print("Colorpicker changed:", Colorpicker.Value)
    -- end)
    
    -- Colorpicker:SetValueRGB(Color3.fromRGB(0, 255, 140))



    -- local TColorpicker = Tabs.Main:AddColorpicker("TransparencyColorpicker", {
    --     Title = "Colorpicker",
    --     Description = "but you can change the transparency.",
    --     Transparency = 0,
    --     Default = Color3.fromRGB(96, 205, 255)
    -- })

    -- TColorpicker:OnChanged(function()
    --     print(
    --         "TColorpicker changed:", TColorpicker.Value,
    --         "Transparency:", TColorpicker.Transparency
    --     )
    -- end)



    -- local Keybind = Tabs.Main:AddKeybind("Keybind", {
    --     Title = "KeyBind",
    --     Mode = "Toggle", -- Always, Toggle, Hold
    --     Default = "LeftControl", -- String as the name of the keybind (MB1, MB2 for mouse buttons)

    --     -- Occurs when the keybind is clicked, Value is `true`/`false`
    --     Callback = function(Value)
    --         print("Keybind clicked!", Value)
    --     end,

    --     -- Occurs when the keybind itself is changed, `New` is a KeyCode Enum OR a UserInputType Enum
    --     ChangedCallback = function(New)
    --         print("Keybind changed!", New)
    --     end
    -- })

    -- OnClick is only fired when you press the keybind and the mode is Toggle
    -- Otherwise, you will have to use Keybind:GetState()
    -- Keybind:OnClick(function()
    --     print("Keybind clicked:", Keybind:GetState())
    -- end)

    -- Keybind:OnChanged(function()
    --     print("Keybind changed:", Keybind.Value)
    -- end)

    -- local Input = Tabs.Main:AddInput("Input", {
    --     Title = "Input",
    --     Default = "Default",
    --     Placeholder = "Placeholder",
    --     Numeric = false, -- Only allows numbers
    --     Finished = false, -- Only calls callback when you press enter
    --     Callback = function(Value)
    --         print("Input changed:", Value)
    --     end
    -- })

    -- Input:OnChanged(function()
    --     print("Input updated:", Input.Value)
    -- end)


-- Addons:
-- SaveManager (Allows you to have a configuration system)
-- InterfaceManager (Allows you to have a interface managment system)

-- Hand the library over to our managers
SaveManager:SetLibrary(Fluent)
InterfaceManager:SetLibrary(Fluent)

-- Ignore keys that are used by ThemeManager.
-- (we dont want configs to save themes, do we?)
SaveManager:IgnoreThemeSettings()

-- You can add indexes of elements the save manager should ignore
SaveManager:SetIgnoreIndexes({})

-- use case for doing it this way:
-- a script hub could have themes in a global folder
-- and game configs in a separate folder per game
InterfaceManager:SetFolder("FluentScriptHub")
SaveManager:SetFolder("FluentScriptHub/specific-game")

InterfaceManager:BuildInterfaceSection(Tabs.Settings)
SaveManager:BuildConfigSection(Tabs.Settings)


Window:SelectTab(1)

-- You can use the SaveManager:LoadAutoloadConfig() to load a config
-- which has been marked to be one that auto loads!
SaveManager:LoadAutoloadConfig()
local emotesscript
local emotes
pcall(function()
emotesscript = require(game:GetService("ReplicatedStorage").Emotes)
end)
print("succesfully required emotes")
pcall(function()
emotes = {[[Bring It]], [[Happy Steps]], [[Fork]], [[Disgraced]], [[Crush]], [[Brush]], [[Spread]], [[Crack]], [[Sweat]], [[Chrono]], [[OK]], [[Honored]], [[Situp]], [[Warmup]], [[Skull]], [[Boxing]], [[Ls]], [[Point Down]], [[Heh]], [[Cart Ride]], [[Soda]], [[Hunter Salute]], [[March]], [[Hunted]], [[Countdown]], [[Ramen]], [[Traditional Duel]], [[Jumping Jacks]], [[Rock Paper Scissor]], [[Snake]], [[Smile]], [[Energized]], [[Party]], [[8 Bit]], [[Nerf This]], [[Moves]], [[Laugh]], [[Steps]], [[You Alright?]], [[I'll Win]], [[Victory Dance]], [[Fool]], [[Boppin]], [[Sleepy]], [[Flex]], [[Boogie]], [[Popcorn]], [[Rock n' Roll]], [[Keyboard Warrior]], [[L]], [[Come]], [[Head Spin]], [[Highfive]], [[Selfie In Style]], [[Crazy]], [[T]], [[Wave]], [[Nuh uh]], [[New Sheriff]], [[Rest]], [[Cheers]], [[Skewed]], [[Bye Bye]], [[Groceries]], [[Rage]], [[Mop]], [[We Ball]], [[Am Dead]], [[Bizarre Handshake]], [[Facepalm]], [[And One]], [[Exercise]], [[Pls]], [[Bow of Respect]], [[Log]], [[Sheathe]], [[Guilty]], [[Pushup]], [[Hunter]], [[Brooming]], [[The Strongest Rocks]], [[Yay]], [[Stay Down]], [[Thinker]], [[Garbage]], [[Salute]], [[First Rule]], [[RAHHH]], [[Bouncy]], [[RK Coin Trick]], [[Confused]], [[Relax]], [[Kneel]], [[Bow]], [[Rolling]], [[Selfie]], [[Sit 2]], [[You Hear That?]], [[RIP]], [[Fresh Fries]], [[Untouchable]], [[4K]], [[WHY?]], [[Levitate]], [[Dap Me Up]], [[Calculated]], [[Bully]], [[Show Me]], [[Read]], [[Kitty Cat]], [[Applause]], [[Cry]], [[Sturdy]], [[Penguin]], [[Chill]], [[Happy]], [[Fist Bump]], [[Chair]], [[Soul]], [[Shuffle]], [[Hologram]], [[Sit 3]], [[Clap Clap]], [[Gun Shot]], [[Expendable]], [[Silence]], [[Weight]], [[Think]], [[Millionare]], [[Table Flip]], [[Salt Shaker]], [[Crowbar]], [[Steel]], [[Pipe Down]], [[Munch]], [[Backflip]], [[Score]], [[360]], [[Wiggle]], [[Skateboard]], [[Coffee]], [[Cook]], [[Umbrella]], [[Sit]], [[Footrest]], [[Relaxed]], [[Comical]], [[Griddy]], [[No Limit]]}
end)
print("succesfully got emotes list")
for i, v in pairs(emotes) do
    pcall(function()
Tabs.PlayEmotes:AddButton({
        Title = v,
        Description = "Play "..v.." Emote",
        Callback = function()
            local Animation = emotesscript.GetTable()[v].Animation
            playanim("rbxassetid://"..Animation)
        end
})
end)
end
Fluent:Notify({
    Title = "Sillyware.meow",
    Content = "Fully Loaded Script!",
    Duration = 5 -- Set to nil to make the notification not disappear
})
